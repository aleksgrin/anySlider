{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/anySlider.js","webpack:///./src/js/app.js","webpack:///(webpack)/buildin/harmony-module.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;AClFA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,SAAS;AACT;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,WAAW;AACX;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,SAAS;AACT;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,yBAAyB;AAC/C;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACjkBA;AAAA;AAAA;AAAA;AAAoC;;AAEf;;;;;;;ACFrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA","file":"bin.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/bin/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","export default class AnySlider {\r\n  constructor() {\r\n    this.sliderValue = null;\r\n    this.sliderHandle = null;\r\n    this.arr = null;\r\n    this.startValue = null;\r\n    this.endValue = null;\r\n    this.totalCurveLength = null;\r\n    this.startEvent = null;\r\n    this.moveEvent = null;\r\n    this.endEvent = null;\r\n  }\r\n\r\n  render(elem, arr) {\r\n    elem.innerHTML = `\r\n      <div class=\"slider_handle\"></div>\r\n      ${this.isVisible ? \"<canvas id='canvas'></canvas>\" : \"\"}\r\n    `;\r\n    if (this.isVisible) {\r\n      const canvas = document.querySelector(\"#canvas\");\r\n      const dotRadius = this.lineWidth / 2;\r\n      canvas.width = this.canvasWidth;\r\n      canvas.height = this.canvasHeight;\r\n      const ctx = canvas.getContext(\"2d\");\r\n\r\n      ctx.beginPath();\r\n      ctx.fillStyle = this.lineColor;\r\n      ctx.lineWidth = 0;\r\n      arr.forEach(elem => {\r\n        ctx.moveTo(elem.x + dotRadius / 2, elem.y + dotRadius / 2);\r\n        ctx.arc(elem.x, elem.y, dotRadius, 0, 2 * Math.PI);\r\n      });\r\n      ctx.fill();\r\n      if (this.referenceValuesArray) {\r\n        ctx.beginPath();\r\n        ctx.lineWidth = this.dashWidth;\r\n        ctx.strokeStyle = this.dashColor;\r\n        this.referenceValuesArray.forEach(referenceElem => {\r\n          const myElem = this.findNearest(\r\n            referenceElem.x,\r\n            referenceElem.y,\r\n            arr\r\n          );\r\n          const dashStart = this.calulateDashCoords(\r\n            myElem,\r\n            arr,\r\n            this.dashHeight / 2\r\n          );\r\n          const dashEnd = this.calulateDashCoords(\r\n            myElem,\r\n            arr,\r\n            -this.dashHeight / 2\r\n          );\r\n          ctx.moveTo(dashStart.x, dashStart.y);\r\n          ctx.lineTo(dashEnd.x, dashEnd.y);\r\n        });\r\n        ctx.stroke();\r\n      }\r\n    }\r\n  }\r\n\r\n  createArray(begin, end, N) {\r\n    const h = (end - begin) / N;\r\n    const arr = [begin];\r\n    for (let i = 1; i <= N; i++) {\r\n      arr.push(arr[i - 1] + h);\r\n    }\r\n    return arr;\r\n  }\r\n  createArrayH(begin, end, h) {\r\n    const N = (end - begin) / h;\r\n    const arr = [begin];\r\n    for (let i = 1; i <= N; i++) {\r\n      arr.push(arr[i - 1] + h);\r\n    }\r\n    return arr;\r\n  }\r\n\r\n  findCurveLength(arr, ind) {\r\n    const sliceInd = ind !== undefined ? ind : arr.length - 1;\r\n    const newArr = arr.slice(0, sliceInd + 1);\r\n    return newArr.reduce((acum, curr, index, array) => {\r\n      return (\r\n        acum +\r\n        (index === 0\r\n          ? 0\r\n          : Math.sqrt(\r\n              Math.pow(curr.x - array[index - 1].x, 2) +\r\n                Math.pow(curr.y - array[index - 1].y, 2)\r\n            ))\r\n      );\r\n    }, 0);\r\n  }\r\n\r\n  findNearest(x, y, arr) {\r\n    // Нахожит ближайшую точку в масиве к переданной\r\n    const dists = arr.map(elem => {\r\n      return Math.sqrt(Math.pow(elem.x - x, 2) + Math.pow(elem.y - y, 2));\r\n    });\r\n    const minInd = dists.indexOf(Math.min(...dists));\r\n    return arr[minInd];\r\n  }\r\n\r\n  checkInput(param) {\r\n    const N = param.type.N || 100;\r\n    if (param.arr) {\r\n      return param.arr;\r\n    }\r\n    if (param.type.curve === \"circle\") {\r\n      const R = param.type.r;\r\n      return this.createArrayH(0, 360, 1)\r\n        .map(elem => (elem * Math.PI) / 180)\r\n        .map(elem => {\r\n          let xAbs = R * Math.cos(elem);\r\n          let yAbs = R * Math.sin(elem);\r\n          return { x: xAbs, y: yAbs };\r\n        });\r\n    }\r\n    if (param.type.curve === \"spiral\") {\r\n      const { fi1, fi2, r1, r2 } = param.type;\r\n      const N = 1000;\r\n      return (\r\n        this.createArray(fi1, fi2, N)\r\n          // return this.createArrayH(fi1, fi2, 1)\r\n          .map(elem => (elem * Math.PI) / 180)\r\n          .map((elem, i) => {\r\n            let xAbs = this.createArray(r1, r2, N)[i] * Math.cos(elem);\r\n            let yAbs = this.createArray(r1, r2, N)[i] * Math.sin(elem);\r\n            return { x: xAbs, y: yAbs };\r\n          })\r\n      );\r\n    }\r\n    if (param.type.curve === \"arc\") {\r\n      const { r, fi1, fi2 } = param.type;\r\n      const dfi = (2 * Math.asin(1 / r / Math.sqrt(2)) * 180) / Math.PI;\r\n      return this.createArrayH(fi1, fi2, dfi)\r\n        .map(elem => (elem * Math.PI) / 180)\r\n        .map(elem => {\r\n          let xAbs = r * Math.cos(elem);\r\n          let yAbs = r * Math.sin(elem);\r\n          return { x: xAbs, y: yAbs };\r\n        });\r\n    }\r\n    if (param.type.curve === \"line\") {\r\n      const { x1, x2, y1, y2 } = param.type;\r\n      const xArr = this.createArray(x1, x2, N);\r\n      const yArr = this.createArray(y1, y2, N);\r\n      return xArr.map((elem, index) => {\r\n        let xAbs = elem;\r\n        let yAbs = yArr[index];\r\n        return { x: xAbs, y: yAbs };\r\n      });\r\n    }\r\n  }\r\n\r\n  line(x1, y1, x2, y2) {\r\n    let xArr;\r\n    let yArr;\r\n    let determineH = (x1, x2) => (x2 < x1 ? -1 : 1);\r\n    if (Math.abs(x2 - x1) > Math.abs(y2 - y1)) {\r\n      xArr = this.createArrayH(x1, x2, determineH(x1, x2));\r\n      yArr = this.createArray(y1, y2, xArr.length - 1);\r\n    } else if (Math.abs(x2 - x1) < Math.abs(y2 - y1)) {\r\n      yArr = this.createArrayH(y1, y2, determineH(y1, y2));\r\n      xArr = this.createArray(x1, x2, yArr.length - 1);\r\n    }\r\n    return xArr.map((elem, index) => {\r\n      let xAbs = elem;\r\n      let yAbs = yArr[index];\r\n      return { x: xAbs, y: yAbs };\r\n    });\r\n  }\r\n  arc(r, fi1, fi2, xc = 0, yc = 0) {\r\n    let dfi = (2 * Math.asin(1 / r / Math.sqrt(2)) * 180) / Math.PI;\r\n    dfi = fi2 > fi1 ? dfi : -dfi;\r\n    return this.createArrayH(fi1, fi2, dfi)\r\n      .map(elem => (elem * Math.PI) / 180)\r\n      .map(elem => {\r\n        let xAbs = xc + r * Math.cos(elem);\r\n        let yAbs = yc + r * Math.sin(elem);\r\n        return { x: xAbs, y: yAbs };\r\n      });\r\n  }\r\n\r\n  calculateValue(start, end, currL, L) {\r\n    return parseInt(((end - start) * currL) / L + start);\r\n  }\r\n\r\n  get() {\r\n    return this.sliderValue;\r\n  }\r\n\r\n  getPersentage() {\r\n    return (this.currL / this.totalCurveLength) * 100;\r\n  }\r\n\r\n  findNearesELemIndex(value, arr) {\r\n    const values = arr.map(elem => Math.abs(elem - value));\r\n    const foundElemIndex = values.indexOf(Math.min(...values));\r\n    return foundElemIndex;\r\n  }\r\n\r\n  set(value) {\r\n    if (this.startValue !== null && this.endValue !== null) {\r\n      if (value > this.endValue || value < this.startValue) {\r\n        console.warn(\r\n          \"Your value is out of your start or end values or you forgot to provied one\"\r\n        );\r\n        return;\r\n      }\r\n      this.sliderValue = value;\r\n      const Lin =\r\n        ((value - this.startValue) * this.totalCurveLength) /\r\n        (this.endValue - this.startValue);\r\n      const foundIndex = this.findNearesELemIndex(Lin, this.curveLengths);\r\n      const foundElem = this.arr[\r\n        this.findNearesELemIndex(Lin, this.curveLengths)\r\n      ];\r\n      this.currentElemIndex = foundIndex;\r\n\r\n      this.moveSliderHandle(foundElem.x, foundElem.y);\r\n    } else {\r\n      this.setPers(value);\r\n    }\r\n  }\r\n\r\n  setPers(value) {\r\n    if (value > 100 || value < 0) {\r\n      console.warn(\r\n        \"Your value is a persent of a curve so it has to be between 0 and 100\"\r\n      );\r\n      return;\r\n    }\r\n    const Lin = (value * this.totalCurveLength) / 100;\r\n    const foundIndex = this.findNearesELemIndex(Lin, this.curveLengths);\r\n    const foundElem = this.arr[foundIndex];\r\n    this.currentElemIndex = foundIndex;\r\n    this.moveSliderHandle(foundElem.x, foundElem.y);\r\n  }\r\n\r\n  listen(type, callback) {\r\n    if (type === \"start\") {\r\n      this.startEvent = new Event(\"start\");\r\n      this.sliderHandle.addEventListener(\"start\", callback, false);\r\n    } else if (type === \"move\") {\r\n      this.moveEvent = new Event(\"move\");\r\n      document.addEventListener(\"move\", callback, false);\r\n    } else if (type === \"end\") {\r\n      this.endEvent = new Event(\"end\");\r\n      document.addEventListener(\"end\", callback, false);\r\n    } else if (type === \"click\") {\r\n      this.clickEvent = new Event(\"click\");\r\n      document.addEventListener(\"click\", callback, false);\r\n    }\r\n  }\r\n\r\n  to(elem) {\r\n    const currInd = this.currentElemIndex;\r\n    const targInd = this.arr.indexOf(elem);\r\n    const slider = this;\r\n\r\n    function animate({ timing, draw, duration }) {\r\n      let start = performance.now();\r\n\r\n      requestAnimationFrame(function animate(time) {\r\n        let timeFraction = (time - start) / duration;\r\n        if (timeFraction > 1) timeFraction = 1;\r\n\r\n        let progress = timing(timeFraction);\r\n\r\n        draw(progress);\r\n\r\n        if (timeFraction < 1) {\r\n          requestAnimationFrame(animate);\r\n        }\r\n      });\r\n    }\r\n\r\n    animate({\r\n      duration: this.transitionTime,\r\n      timing: slider.timingFunction,\r\n      draw(progress) {\r\n        let i = Math.floor((targInd - currInd) * progress + currInd);\r\n        if (i >= slider.arr.length) {\r\n          i = slider.arr.length - 1;\r\n        }\r\n        if (i < 0) {\r\n          i = 0;\r\n        }\r\n        slider.moveSliderHandle(slider.arr[i].x, slider.arr[i].y);\r\n      }\r\n    });\r\n    this.currentElemIndex = targInd;\r\n  }\r\n\r\n  moveSliderHandle(x, y) {\r\n    this.sliderHandle.style.left = x - this.sliderHandle.offsetWidth / 2 + \"px\";\r\n    this.sliderHandle.style.top = y - this.sliderHandle.offsetHeight / 2 + \"px\";\r\n  }\r\n\r\n  moveSliderHandleToNearestRef(x, y) {\r\n    const foundReferenceElem = this.findNearest(\r\n      this.foundElem.x,\r\n      this.foundElem.y,\r\n      this.referenceValuesArray\r\n    );\r\n    this.foundElem = this.findNearest(\r\n      foundReferenceElem.x,\r\n      foundReferenceElem.y,\r\n      this.arr\r\n    );\r\n    this.to(this.foundElem);\r\n  }\r\n\r\n  handleReferenceValues() {\r\n    return this.referenceValues.map(value => {\r\n      if (value > this.endValue || value < this.startValue) {\r\n        console.warn(\r\n          \"Your value is out of your start or end values or you forgot to provied one\"\r\n        );\r\n        return;\r\n      }\r\n      const Lin =\r\n        ((value - this.startValue) * this.totalCurveLength) /\r\n        (this.endValue - this.startValue);\r\n      return this.arr[this.findNearesELemIndex(Lin, this.curveLengths)];\r\n    });\r\n  }\r\n\r\n  shiftInputArray(arr) {\r\n    const arrMinX = Math.min(...arr.map(elem => elem.x));\r\n    const arrMaxX = Math.max(...arr.map(elem => elem.x));\r\n    const arrMinY = Math.min(...arr.map(elem => elem.y));\r\n    const arrMaxY = Math.max(...arr.map(elem => elem.y));\r\n    return arr.map(elem => {\r\n      elem.y += 10;\r\n      elem.x += 10;\r\n      if (arrMinY < 0) {\r\n        elem.y -= arrMinY - 20;\r\n      }\r\n      if (arrMinX < 0) {\r\n        elem.x -= arrMinX - 20;\r\n      }\r\n      return elem;\r\n    });\r\n  }\r\n  calulateDashCoords(elem, arr, r) {\r\n    const elemIndex = arr.indexOf(elem);\r\n    const diff =\r\n      elemIndex === arr.length - 1\r\n        ? (arr[elemIndex].y - arr[elemIndex - 1].y) /\r\n          (arr[elemIndex].x - arr[elemIndex - 1].x)\r\n        : (arr[elemIndex + 1].y - arr[elemIndex].y) /\r\n          (arr[elemIndex + 1].x - arr[elemIndex].x);\r\n    // const diff2 =\r\n    //   (arr[elemIndex + 1].y - 2 * arr[elemIndex].y + arr[elemIndex - 1].y) /\r\n    //   Math.pow(arr[elemIndex + 1].x - arr[elemIndex].x, 2);\r\n\r\n    const alpha = Math.atan(diff);\r\n\r\n    const fiAdd = 0;\r\n    // const fiAdd = diff2 > 0 ? Math.PI : 0;\r\n\r\n    return {\r\n      x: elem.x + r * Math.cos(fiAdd + Math.PI / 2 + alpha),\r\n      y: elem.y + r * Math.sin(fiAdd + Math.PI / 2 + alpha)\r\n    };\r\n  }\r\n\r\n  init(elem, param) {\r\n    // Константы\r\n    const defaultTransitionTime = 800;\r\n    const defaultTimingFunction = timeFraction => {\r\n      return timeFraction;\r\n    };\r\n    const cutoffInd = 30;\r\n\r\n    // Начальные значения\r\n    this.currentElemIndex = 0;\r\n\r\n    // Обработка входных параметров\r\n    this.transitionTime =\r\n      param.transition && param.transition.t\r\n        ? param.transition.t\r\n        : defaultTransitionTime;\r\n    this.timingFunction =\r\n      param.transition && param.transition.timingFunction\r\n        ? param.transition.timingFunction\r\n        : defaultTimingFunction;\r\n\r\n    this.startValue = param.values ? param.values.from : null;\r\n    this.endValue = param.values ? param.values.to : null;\r\n\r\n    this.behavor = param.behavior ? param.behavior : null;\r\n    this.isToggle =\r\n      this.behavor && this.behavor.toggle === true ? this.behavor.toggle : null;\r\n\r\n    this.referenceValues = param.referenceValues\r\n      ? param.referenceValues.values\r\n      : null;\r\n    this.isVisible =\r\n      param.render && param.render.visible !== undefined\r\n        ? param.render.visible\r\n        : true;\r\n    this.closed = param.type.closed ? param.type.closed : null;\r\n    this.lineColor =\r\n      param.render && param.render.color ? param.render.color : \"#000000\";\r\n    this.lineWidth =\r\n      param.render && param.render.width ? param.render.width : 4;\r\n    this.dashColor =\r\n      param.render && param.render.dashColor ? param.render.dashColor : \"black\";\r\n    this.dashWidth =\r\n      param.render && param.render.dashWidth ? param.render.dashWidth : 4;\r\n    this.dashHeight =\r\n      param.render && param.render.dashHeight ? param.render.dashHeight : 40;\r\n\r\n    this.elem = elem;\r\n    this.arr = this.checkInput(param);\r\n    this.arr = this.shiftInputArray(this.arr);\r\n    this.curveLengths = this.arr.map((elem, ind, arr) => {\r\n      return this.findCurveLength(arr, ind);\r\n    });\r\n\r\n    this.canvasWidth = Math.max(...this.arr.map(elem => elem.x)) + 50;\r\n    this.canvasHeight = Math.max(...this.arr.map(elem => elem.y)) + 50;\r\n    this.totalCurveLength = this.findCurveLength(this.arr);\r\n\r\n    this.referenceValuesArray =\r\n      this.referenceValues && this.handleReferenceValues();\r\n    this.render(this.elem, this.arr);\r\n    this.sliderElem = document.querySelector(\".slider\");\r\n    this.sliderHandle = document.querySelector(\".slider_handle\");\r\n    const sliderLeft = this.sliderElem.offsetLeft;\r\n    const sliderTop = this.sliderElem.offsetTop;\r\n\r\n    this.moveSliderHandle(this.arr[0].x, this.arr[0].y);\r\n\r\n    let getCoordsStorage = evt => {\r\n      return evt.targetTouches ? evt.targetTouches[0] : evt;\r\n    };\r\n\r\n    if (param.clickable !== false) {\r\n      let onSliderClick = evt => {\r\n        if (this.clickEvent) this.elem.dispatchEvent(this.clickEvent);\r\n\r\n        evt.preventDefault();\r\n        let coords = {\r\n          x: getCoordsStorage(evt).clientX - sliderLeft,\r\n          y: getCoordsStorage(evt).clientY - sliderTop\r\n        };\r\n\r\n        this.foundElem = this.findNearest(coords.x, coords.y, this.arr);\r\n        if (param.referenceValues) {\r\n          const foundReferenceElem = this.findNearest(\r\n            this.foundElem.x,\r\n            this.foundElem.y,\r\n            this.referenceValuesArray\r\n          );\r\n          this.foundElem = this.findNearest(\r\n            foundReferenceElem.x,\r\n            foundReferenceElem.y,\r\n            this.arr\r\n          );\r\n          this.foundElemIndex = this.arr.indexOf(this.foundElem);\r\n          this.targetElemIndex = this.foundElemIndex;\r\n          this.moveSliderHandleToNearestRef();\r\n        } else {\r\n          this.foundElemIndex = this.arr.indexOf(this.foundElem);\r\n          this.targetElemIndex = this.foundElemIndex;\r\n          this.to(this.foundElem);\r\n        }\r\n\r\n        this.currentElemIndex = this.foundElemIndex;\r\n        this.currL = this.findCurveLength(this.arr, this.foundElemIndex);\r\n        if (param.values) {\r\n          this.sliderValue = this.calculateValue(\r\n            this.startValue,\r\n            this.endValue,\r\n            this.currL,\r\n            this.totalCurveLength\r\n          );\r\n        } else {\r\n          this.sliderValue = this.getPersentage();\r\n        }\r\n      };\r\n      this.sliderElem.addEventListener(\"click\", onSliderClick);\r\n    }\r\n\r\n    let onMouseDown = evt => {\r\n      evt.preventDefault();\r\n\r\n      if (this.startEvent) this.sliderHandle.dispatchEvent(this.startEvent);\r\n\r\n      let coords = {\r\n        x: getCoordsStorage(evt).clientX - sliderLeft,\r\n        y: getCoordsStorage(evt).clientY - sliderTop\r\n      };\r\n\r\n      let onMouseMove = moveEvt => {\r\n        moveEvt.preventDefault();\r\n\r\n        if (this.moveEvent) document.dispatchEvent(this.moveEvent);\r\n\r\n        this.foundElem = this.findNearest(coords.x, coords.y, this.arr);\r\n        this.foundElemIndex = this.arr.indexOf(this.foundElem);\r\n        this.currElem = this.arr[this.currentElemIndex];\r\n\r\n        const isClosedCurve = () => {\r\n          return (\r\n            (this.closed &&\r\n              this.currentElemIndex >= this.arr.length - cutoffInd &&\r\n                this.foundElemIndex < cutoffInd) ||\r\n            (this.currentElemIndex < cutoffInd &&\r\n              this.foundElemIndex > this.arr.length - cutoffInd)\r\n          );\r\n        };\r\n\r\n        if (\r\n          Math.abs(this.foundElemIndex - this.currentElemIndex) < cutoffInd ||\r\n          isClosedCurve()\r\n        ) {\r\n          this.currentElemIndex = this.foundElemIndex;\r\n          this.moveSliderHandle(this.foundElem.x, this.foundElem.y);\r\n        }\r\n\r\n        coords = {\r\n          x: getCoordsStorage(moveEvt).clientX - sliderLeft,\r\n          y: getCoordsStorage(moveEvt).clientY - sliderTop\r\n        };\r\n\r\n        const currInd = this.arr.indexOf(this.foundElem);\r\n        this.currL = this.findCurveLength(this.arr, currInd);\r\n        if (param.values) {\r\n          this.sliderValue = this.calculateValue(\r\n            this.startValue,\r\n            this.endValue,\r\n            this.currL,\r\n            this.totalCurveLength\r\n          );\r\n        } else {\r\n          this.sliderValue = this.getPersentage();\r\n        }\r\n      };\r\n\r\n      let onMouseUp = upEvt => {\r\n        upEvt.preventDefault();\r\n        if (this.endEvent) document.dispatchEvent(this.endEvent);\r\n\r\n        if (this.referenceValuesArray) {\r\n          const foundReferenceElem = this.findNearest(\r\n            this.foundElem.x,\r\n            this.foundElem.y,\r\n            this.referenceValuesArray\r\n          );\r\n          this.foundElem = this.findNearest(\r\n            foundReferenceElem.x,\r\n            foundReferenceElem.y,\r\n            this.arr\r\n          );\r\n          this.to(this.foundElem);\r\n        }\r\n\r\n        document.removeEventListener(\"mousemove\", onMouseMove);\r\n        document.removeEventListener(\"touchmove\", onMouseMove);\r\n        document.removeEventListener(\"mouseup\", onMouseUp);\r\n        document.removeEventListener(\"touchend\", onMouseUp);\r\n      };\r\n      document.addEventListener(\"mousemove\", onMouseMove);\r\n      document.addEventListener(\"touchmove\", onMouseMove);\r\n      document.addEventListener(\"mouseup\", onMouseUp);\r\n      document.addEventListener(\"touchend\", onMouseUp);\r\n    };\r\n    this.sliderHandle.addEventListener(\"mousedown\", onMouseDown);\r\n    this.sliderHandle.addEventListener(\"touchstart\", onMouseDown);\r\n  }\r\n}\r\n\r\nmodule.exports.AnySlider = AnySlider;\r\n","import AnySlider from \"./anySlider\";\r\n\r\nexport { AnySlider };\r\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n"],"sourceRoot":""}